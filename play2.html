<!DOCTYPE html> <!-- Corrected DOCTYPE -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Editor with Animation Grapher</title> <!-- Updated title -->
    <script src="all.min.js"></script> <!-- Local FontAwesome -->

    <!-- Graphing Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/nerdamer.core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/LaTeX.min.js"></script>
    <script src="https://unpkg.com/function-plot/dist/function-plot.js"></script>

    <!-- LaTeXJS (if needed for input display, though Nerdamer handles conversion) -->
    <script type="module">
        import { LaTeXJSComponent } from "https://cdn.jsdelivr.net/npm/latex.js/dist/latex.mjs"
        customElements.define("latex-js", LaTeXJSComponent)
    </script>

    <style>
        /* --- Paste ALL CSS from simple.html here --- */
        /* ... (ensure all the styles from your simple.html example are included) ... */

        /* --- ADD/MERGE THESE STYLES for Animation Controls --- */
        #animationControls {
            display: flex;
            align-items: center;
            gap: 6px; /* Spacing between elements */
            /* flex-grow: 1; */ /* Allow it to take space */
            color: var(--text-secondary);
            font-size: 13px;
            margin-right: 10px; /* Space before other buttons */
        }
        #animationControls label {
            white-space: nowrap; /* Prevent labels from wrapping */
        }
        #animationControls input[type="number"] {
            width: 45px; /* Slightly smaller */
            padding: 4px;
            background-color: var(--editor-bg); /* Match theme */
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px; /* Match theme */
            font-size: 12px; /* Smaller font */
            height: auto; /* Override potential default heights */
        }
        #animationControls button {
            padding: 6px 10px; /* Match theme button size */
            background-color: var(--editor-bg); /* Match theme */
            color: var(--text-primary); /* Match theme */
            border: 1px solid var(--border-color); /* Match theme */
            border-radius: 4px; /* Match theme */
            cursor: pointer;
            font-size: 12px; /* Smaller font */
            transition: all var(--transition-fast); /* Use theme transition */
        }
        #animationControls button:hover {
            background-color: var(--btn-hover-bg); /* Use theme hover */
            color: var(--btn-primary-text);
        }
        #animationControls button:disabled {
            background-color: #3a4155;
            cursor: not-allowed;
            opacity: 0.6;
        }
        #kValueDisplayContainer {
             margin-left: 5px;
             min-width: 50px; /* Ensure space */
             display: inline-block;
             font-weight: bold;
             color: var(--accent-color); /* Use accent if defined, else primary */
             font-size: 13px;
             display: none; /* Hide initially */
             margin-right: 10px; /* Space before controls */
        }
         #kValueDisplay {
              /* Already styled via container */
         }

        /* Ensure htmlOutput takes space */
        .html-viewer {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden; /* Prevent double scroll */
        }
        #htmlOutput {
            flex: 1;
            background-color: white; /* Default function plot background */
            overflow: auto; /* Allow scrolling if graph is large */
            /* Reset padding/margins if needed */
            padding: 0;
            margin: 0;
            position: relative; /* Needed for function-plot */
            min-height: 100px; /* Ensure it doesn't collapse */
        }
        #htmlOutput canvas {
             display: block; /* Prevent extra space below canvas */
             /* function-plot handles canvas styling mostly */
        }

        /* Style for error messages shown in console viewer */
        .plot-error-message {
            color: #ff4d4f; /* Red */
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            white-space: pre-wrap;
            margin-top: 10px;
            border-top: 1px dashed var(--border-color);
            padding-top: 5px;
        }
    </style>
</head>
<!-- Add class="advanced-mode" to body if needed by default -->
<body>

    <!-- Paste the ENTIRE BODY HTML from simple.html here -->
    <!-- ... (header, editors-container, viewers-container, modals etc.) ... -->

    <!-- *** KEY MODIFICATION AREA: Inside .viewers-container -> .html-viewer-column -> .viewer-header *** -->
    <div class="viewers-container">
        <div class="html-viewer-column">
            <div class="viewer-header">
                <!-- Existing Left Content (like title) -->
                <span>HTML Preview / Graph</span> <!-- Updated Title -->

                <!-- Existing Right Content (button group) -->
                <div style="display: flex; align-items: center; "> <!-- Wrapper for controls + buttons -->
                    <!-- K Value Display -->
                     <span id="kValueDisplayContainer">
                         k = <span id="kValueDisplay">0.00</span>
                     </span>

                    <!-- Animation Controls -->
                    <div id="animationControls">
                        <button id="animPlayPauseButton" disabled>Play</button>
                        <button id="animResetButton" disabled>Reset</button>
                        <label for="kMinInput">k Min:</label>
                        <input type="number" id="kMinInput" value="0" step="any">
                        <label for="kMaxInput">k Max:</label>
                        <input type="number" id="kMaxInput" value="10" step="any">
                        <label for="kStepInput">Step:</label>
                        <input type="number" id="kStepInput" value="0.1" step="any">
                    </div>

                    <!-- Existing Button Group (Library, Share, Gallery, Record, Fullscreen, Refresh) -->
                    <div class="js-library-dropdown">
                        <button class="btn1" id="jsLibraryBtn" >
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">...</svg>
                            Library
                        </button>
                        <div class="dropdown-menu" id="jsLibraryMenu">...</div>
                    </div>
                    <div style="display: flex; border: 1px solid var(--border-color) !important; border-radius: 4px; overflow: hidden; margin-left: 6px;">
                        <button class="btn" id="shareBtn" >
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">...</svg>
                        </button>
                        <div class="tab-buttons" >
                            <button class="tab-button" data-tab="gallery">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">...</svg>
                            </button>
                        </div>
                        <button class="btn" id="recordButton" >
                           <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">...</svg>
                        </button>
                        <button class="btn" id="toggleFullscreen" >
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">...</svg>
                        </button>
                        <button class="btn btn-run" id="refreshPreview" style="background-color: var(--editor-bg) !important;" >
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">...</svg>
                            Refresh
                        </button>
                    </div> <!-- End of existing button group div -->
                 </div> <!-- End Wrapper -->
            </div>
            <!-- HTML Output Area (Target for Graph) -->
            <div class="viewer html-viewer" id="htmlOutput">
                <!-- Content will be replaced by graph or standard preview -->
                 <div style="padding: 20px; color: var(--text-secondary); text-align: center;">
                     Preview Area. Type JS code or equations (using 'k') in the JS editor and press Refresh.
                 </div>
            </div>
        </div>
        <!-- CSS/JS Viewer Column (Console Output) -->
        <div class="css-js-viewer-column">
            <div class="tab-switcher">
                <div class="tab active" data-tab="console">Console</div>
                <div class="tab" data-tab="css">CSS Output</div>
            </div>
            <div class="viewer js-viewer" id="jsOutput" data-tab-content="console">
                <!-- JS output/console & Graphing Errors will be displayed here -->
            </div>
            <div class="viewer css-viewer" id="cssOutput" data-tab-content="css" style="display: none;">
                <!-- CSS output will be displayed here -->
            </div>
        </div>
    </div>

    <!-- ... (Rest of the body content: modals, canvases, scripts links for main.js etc.) ... -->
    <script src="tutorial.js"></script>
    <script src="main.js"></script> <!-- Assuming this handles standard preview -->
    <script src="api-payment.js"></script>
    <script src="ai-api.js"></script>
    <script src="container-resize.js"></script>
    <script src="text-analysis-api.js"></script>
    <script src= "extra.js"></script>

    <!-- *** ADD THE ANIMATION SCRIPT LOGIC HERE *** -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Get DOM Elements ---
            const equationInput = document.getElementById('jsEditor'); // *** CHANGED Target ***
            const generateButton = document.getElementById('refreshPreview'); // *** CHANGED Target ***
            const graphOutputDiv = document.getElementById('htmlOutput'); // *** CHANGED Target ***
            const jsConsoleOutput = document.getElementById('jsOutput'); // *** ADDED for errors ***

            // Animation elements
            const animPlayPauseButton = document.getElementById('animPlayPauseButton');
            const animResetButton = document.getElementById('animResetButton');
            const kMinInput = document.getElementById('kMinInput');
            const kMaxInput = document.getElementById('kMaxInput');
            const kStepInput = document.getElementById('kStepInput');
            const kValueDisplay = document.getElementById('kValueDisplay');
            const kValueDisplayContainer = document.getElementById('kValueDisplayContainer');

            // --- State Variables ---
            let plotInstance = null;
            let currentPlotOptions = {}; // Stores options for redraw/animation
            let parsedEquationData = []; // Store the parsed structures
            let isGraphModeActive = false; // Track if the graph is currently displayed

            // Animation state
            let isAnimating = false;
            let animationFrameId = null;
            let kValue = 0;
            let kMin = 0;
            let kMax = 10;
            let kStep = 0.1;
            let requiresK = false; // Does the current set of equations use 'k'?

            // --- Helper Function to Display Errors in Console ---
            function displayGraphError(message) {
                console.error("Graph Error:", message);
                const errorElement = document.createElement('div');
                errorElement.className = 'plot-error-message'; // Add class for styling
                errorElement.textContent = `GRAPH ERROR: ${message}`;
                jsConsoleOutput.appendChild(errorElement);
                // Scroll console to bottom
                jsConsoleOutput.scrollTop = jsConsoleOutput.scrollHeight;
            }


            // --- Helper: Preprocesses a single equation string ---
            function preprocessEquation(str) {
                // Replace common representations of pi and theta
                str = str.replace(/π/g, 'pi')
                         .replace(/θ/g, 'theta');
                // Convert x2 -> x^2 etc. (handle potential lookbehind issues)
                try {
                    str = str.replace(/(?<![a-zA-Z0-9\.])([xytk])(\d+)/g, '$1^$2'); // Added 'k'
                } catch (e) {
                    console.warn("Regex lookbehind might not be supported.");
                    str = str.replace(/\b([xytk])(\d+)\b/g, '$1^$2'); // Added 'k'
                }
                return str;
            }

            // --- Helper: Parses a SINGLE equation string ---
            function parseSingleEquation(singleEqStr) {
                let rawEq = singleEqStr.trim();
                if (!rawEq) {
                    return { data: null, error: null, usesK: false }; // Ignore empty lines/parts
                }

                let convertedInput;
                let conversionError = null;
                let usesK = false; // Track if 'k' is present

                // Attempt LaTeX conversion first
                try {
                    // Check if it *looks* like LaTeX before attempting conversion
                     if (rawEq.includes('\\') || rawEq.includes('^') || rawEq.includes('_') || rawEq.includes('{') || rawEq.includes('}')) {
                        convertedInput = nerdamer.fromLaTeX(rawEq).toString();
                        // Nerdamer sometimes wraps in unnecessary parens
                        if (convertedInput.startsWith('(') && convertedInput.endsWith(')')) {
                            try { math.parse(convertedInput.substring(1, convertedInput.length - 1)); convertedInput = convertedInput.substring(1, convertedInput.length - 1); }
                            catch (e) { /* Keep outer parens if inner parse fails */ }
                        }
                         console.log(`Raw: "${rawEq}", Nerdamer attempt: "${convertedInput}"`);
                    } else {
                         convertedInput = rawEq; // Assume not LaTeX if no common chars
                         console.log(`Raw: "${rawEq}", Skipped Nerdamer (no obvious LaTeX)`);
                     }
                } catch (latexError) {
                    convertedInput = rawEq; // Fallback to raw input on error
                    conversionError = `(Input "${rawEq}" not valid LaTeX or failed conversion: ${latexError.message})`;
                    console.warn(`Nerdamer failed for "${rawEq}": ${latexError.message}`);
                }

                let equationStr = preprocessEquation(convertedInput);
                let plotData = null;
                let parseError = null;
                console.log(`Processing for plot: "${equationStr}"`);

                // Check if 'k' exists BEFORE parsing structure
                if (/\bk\b/.test(equationStr)) {
                    usesK = true;
                    console.log("Found 'k', setting usesK = true");
                } else {
                    console.log("Did not find 'k'");
                }

                try {
                    // Check for keywords first (Parametric, Polar, Implicit)
                    if (equationStr.toLowerCase().startsWith('parametric:')) {
                        const definition = equationStr.substring('parametric:'.length).trim();
                        const parts = definition.split(/[,;]/); // Allow comma or semicolon
                        let xFn = null, yFn = null;
                        parts.forEach(part => {
                            const eqParts = part.split('=');
                            if (eqParts.length === 2) {
                                const variable = eqParts[0].trim().toLowerCase();
                                const expression = eqParts[1].trim();
                                if (variable === 'x') xFn = expression;
                                else if (variable === 'y') yFn = expression;
                            }
                        });
                        if (!xFn || !yFn) throw new Error("Parametric format error. Use 'parametric: x=f(t,k), y=g(t,k)'.");
                        plotData = { fnType: 'parametric', x: xFn, y: yFn, graphType: 'polyline' };

                    } else if (equationStr.toLowerCase().startsWith('polar:')) {
                        const definition = equationStr.substring('polar:'.length).trim();
                        if (!definition.toLowerCase().startsWith('r=')) throw new Error("Polar format error. Use 'polar: r = f(theta,k)'.");
                        const rFn = definition.substring(definition.indexOf('=') + 1).trim();
                        plotData = { fnType: 'polar', r: rFn, graphType: 'polyline' };

                    } else if (equationStr.toLowerCase().startsWith('implicit:')) {
                        const definition = equationStr.substring('implicit:'.length).trim();
                        const parts = definition.split('=').map(p => p.trim());
                         if (parts.length === 1) { // Assume implicit: f(x,y,k) = 0
                             plotData = { fnType: 'implicit', fn: parts[0] };
                         } else if (parts.length === 2) { // implicit: f(x,y,k) = g(x,y,k)
                            const implicitFn = `(${parts[0]}) - (${parts[1]})`;
                            plotData = { fnType: 'implicit', fn: implicitFn };
                        } else { throw new Error("Implicit format error. Use 'implicit: f(x,y,k)=0' or 'implicit: f(x,y,k) = g(x,y,k)'."); }

                    } else if (equationStr.includes('=')) {
                        const parts = equationStr.split('=').map(part => part.trim());
                        if (parts.length === 2) {
                            let lhs = parts[0]; let rhs = parts[1];
                            const lhsHasX = /\bx\b/.test(lhs); const lhsHasY = /\by\b/.test(lhs);
                            const rhsHasX = /\bx\b/.test(rhs); const rhsHasY = /\by\b/.test(rhs);

                            if (lhs === 'y' && !rhsHasY) { // Basic y = f(x, k)
                                plotData = { fn: rhs, graphType: 'polyline' };
                            } else if (lhs === 'x' && !rhsHasX && lhsHasY) { // x = f(y, k) -> Plot parametric x=f(t,k), y=t
                                plotData = { fnType: 'parametric', x: rhs.replace(/\by\b/g, 't'), y: 't', graphType: 'polyline' };
                                console.log("Converted x=f(y) to parametric");
                            } else { // General implicit: f(x,y,k) = g(x,y,k) -> f - g = 0
                                const implicitFn = `(${lhs}) - (${rhs})`;
                                plotData = { fnType: 'implicit', fn: implicitFn };
                             }
                        } else { throw new Error("Invalid equation format. Expected 'LHS = RHS'."); }
                    } else {
                        // Assume y = f(x, k) if just an expression containing x or k
                        if (/\bx\b/.test(equationStr) || /\bk\b/.test(equationStr) || equationStr.match(/^[\d\s\.\+\-\*\/pi\(\)]+$/) ) {
                           plotData = { fn: equationStr, graphType: 'polyline' };
                       } else { throw new Error("Invalid input. Expected function like y=f(x,k), an equation, or specific format (polar:, parametric:, implicit:)."); }
                    }

                    // Try a quick parse check with math.js (including 'k' in scope)
                    if(plotData) {
                        const testScope = { x: 1, y: 1, t: 1, theta: 1, k: 1 }; // Provide dummy values
                        if (plotData.fn) math.compile(plotData.fn).evaluate(testScope);
                        if (plotData.x) math.compile(plotData.x).evaluate(testScope);
                        if (plotData.y) math.compile(plotData.y).evaluate(testScope);
                        if (plotData.r) math.compile(plotData.r).evaluate(testScope);
                    }

                } catch(error) {
                    console.error(`Parsing Error for "${rawEq}" (processed as "${equationStr}"):`, error);
                    parseError = `Error processing "${rawEq}": ${error.message}`;
                    if (conversionError) { parseError += ` ${conversionError}`; }
                    plotData = null;
                    usesK = false; // Can't use k if there's a parse error
                }

                return { data: plotData, error: parseError, usesK: usesK };
            }


            // --- Animation Step Function ---
            function animateStep() {
                if (!isAnimating || !isGraphModeActive) return;

                kValue += kStep;
                if ((kStep > 0 && kValue > kMax) || (kStep < 0 && kValue < kMin)) {
                    // Option 1: Clamp and Stop
                    kValue = (kStep > 0) ? kMax : kMin;
                    stopAnimation();

                    // Option 2: Loop
                    // kValue = (kStep > 0) ? kMin : kMax;
                }

                updateKDisplay();
                drawCurrentFrame(); // Redraw with new k

                // Request next frame if still animating
                if (isAnimating) {
                    animationFrameId = requestAnimationFrame(animateStep);
                }
            }

            // --- Start Animation ---
            function startAnimation() {
                 if (isAnimating || !requiresK || !isGraphModeActive) return;
                isAnimating = true;
                animPlayPauseButton.textContent = 'Pause';
                animResetButton.disabled = false; // Enable reset when playing

                // Ensure k starts from the beginning if it reached the end
                if ((kStep > 0 && kValue >= kMax) || (kStep < 0 && kValue <= kMin)) {
                    kValue = kMin;
                }

                updateKDisplay();
                kValueDisplayContainer.style.display = 'inline-block'; // Show k value
                animationFrameId = requestAnimationFrame(animateStep);
            }

            // --- Pause Animation ---
            function pauseAnimation() {
                if (!isAnimating) return;
                isAnimating = false;
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                animPlayPauseButton.textContent = 'Play';
            }

             // --- Stop Animation (distinct from pause) ---
             function stopAnimation() {
                 if (!isAnimating && animationFrameId === null) return; // Already stopped
                 isAnimating = false;
                 if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                 }
                 animPlayPauseButton.textContent = 'Play';
                 // Reset button remains enabled after stopping until explicitly reset
                 animResetButton.disabled = false;
             }

            // --- Reset Animation ---
            function resetAnimation() {
                stopAnimation(); // Ensure loop is stopped
                kValue = kMin; // Reset k to minimum
                updateKDisplay();
                 if (isGraphModeActive && parsedEquationData.length > 0) {
                    drawCurrentFrame(); // Draw the initial state
                 }
                animResetButton.disabled = true; // Disable reset until played again
                if (!requiresK) { // Hide k display if no longer relevant
                     kValueDisplayContainer.style.display = 'none';
                }
            }

             // --- Update K Value Display ---
            function updateKDisplay() {
                kValueDisplay.textContent = kValue.toFixed(2); // Format to 2 decimal places
            }

            // --- Draw a Single Frame ---
            function drawCurrentFrame() {
                if (!isGraphModeActive || parsedEquationData.length === 0) {
                    console.warn("Attempted to draw frame when graph mode not active or no data.");
                    return;
                }
                if (!graphOutputDiv) {
                     displayGraphError("Graph output div (#htmlOutput) not found.");
                     return;
                }

                 // --- WORKAROUND for scope issues with implicit/other types ---
                 // Create temporary data for this frame, substituting 'k' value.
                 const frameSpecificData = parsedEquationData.map(eqData => {
                     const newEqData = { ...eqData };
                     const kString = `(${kValue.toFixed(10)})`; // High precision string, wrap in parens

                     try {
                         // Replace '\bk\b' only to avoid replacing 'k' in function names like 'sqrt'
                         const kRegex = /\bk\b/g;
                         if (newEqData.fnType === 'implicit' && kRegex.test(newEqData.fn)) {
                             newEqData.fn = newEqData.fn.replace(kRegex, kString);
                         } else if (newEqData.fnType === 'parametric') {
                             if (newEqData.x && kRegex.test(newEqData.x)) {
                                 newEqData.x = newEqData.x.replace(kRegex, kString);
                             }
                             if (newEqData.y && kRegex.test(newEqData.y)) {
                                 newEqData.y = newEqData.y.replace(kRegex, kString);
                             }
                         } else if (newEqData.fnType === 'polar' && newEqData.r && kRegex.test(newEqData.r)) {
                             newEqData.r = newEqData.r.replace(kRegex, kString);
                         } else if (!newEqData.fnType && newEqData.fn && kRegex.test(newEqData.fn)) { // Explicit y=f(x) or constant=k
                              newEqData.fn = newEqData.fn.replace(kRegex, kString);
                         }
                     } catch (replaceError) {
                         displayGraphError(`Error substituting k=${kValue} into function string: ${replaceError.message}`);
                         return eqData; // Return original if substitution fails
                     }
                     return newEqData;
                 });
                 // --- End Workaround ---


                let plotOptions = {
                    target: '#htmlOutput', // Target the div
                    width: currentPlotOptions.width || graphOutputDiv.clientWidth || 600,
                    height: currentPlotOptions.height || graphOutputDiv.clientHeight || 400,
                    grid: true,
                    data: frameSpecificData, // Use frame-specific data
                    // Scope is less reliable, substitution is preferred
                    // scope: { k: kValue }
                };

                // Reuse existing x/y domains if available (important for zoom/pan)
                if (currentPlotOptions.xAxis?.domain && currentPlotOptions.yAxis?.domain) {
                    plotOptions.xAxis = { domain: [...currentPlotOptions.xAxis.domain] };
                    plotOptions.yAxis = { domain: [...currentPlotOptions.yAxis.domain] };
                } else {
                    // Sensible defaults if first plot or domains lost
                    plotOptions.xAxis = { domain: [-10, 10] };
                    plotOptions.yAxis = { domain: [-10, 10] };
                }

                try {
                    // Store the latest options used (mainly for resize)
                    // Store ORIGINAL data with 'k', not substituted version
                    currentPlotOptions = {
                         ...plotOptions,
                         data: parsedEquationData // <<< Store original data with 'k'
                    };

                     // Clear target before plotting (functionPlot might do this, but safer)
                     // graphOutputDiv.innerHTML = ''; // Reconsider this, might cause flicker during animation

                    // Create/Update the plot instance
                     // functionPlot might reuse the existing instance if target hasn't changed
                    plotInstance = functionPlot(plotOptions);

                     // --- Event listeners for the plot instance ---
                     plotInstance.on('error', (err) => {
                         displayGraphError(`Runtime Plot Error (k=${kValue.toFixed(2)}): ${err.message || err}`);
                         stopAnimation();
                     });

                    // Listener to capture zoom/pan changes and update stored domains
                     plotInstance.on('all', (eventName, ...args) => {
                         // Check for zoom/pan events (these might differ slightly by version)
                         // Common events: 'zoom', 'pan', 'programmatic-zoom'
                         if (['zoom', 'pan', 'programmatic-zoom', 'tip:drag', 'mousemove'].includes(eventName)) { // Listen to relevant events
                             if (plotInstance && plotInstance.meta) {
                                 // Check if scales and domain() function exist before accessing
                                 if(plotInstance.meta.xScale?.domain) {
                                     const newXDomain = plotInstance.meta.xScale.domain();
                                     if (newXDomain && newXDomain.length === 2) {
                                         currentPlotOptions.xAxis = { domain: [...newXDomain] };
                                     }
                                 }
                                 if(plotInstance.meta.yScale?.domain) {
                                     const newYDomain = plotInstance.meta.yScale.domain();
                                      if (newYDomain && newYDomain.length === 2) {
                                           currentPlotOptions.yAxis = { domain: [...newYDomain] };
                                      }
                                 }
                                // console.log("Updated domains:", currentPlotOptions.xAxis, currentPlotOptions.yAxis);
                             }
                         }
                     });

                } catch (plottingError) {
                    displayGraphError(`FunctionPlot Instantiation Error: ${plottingError.message}`);
                    console.error("Plotting Error Details:", plottingError);
                    plotInstance = null;
                    stopAnimation(); // Stop animation on plot setup error
                    // Maybe clear the output area or show error there too
                    graphOutputDiv.innerHTML = `<div class='plot-error-message' style='padding:20px;'>Plotting Error: ${plottingError.message}</div>`;

                }
            }

            // --- Main Plotting Function ---
            function plotGraph() {
                console.log("Attempting to plot graph...");
                stopAnimation(); // Stop any existing animation
                jsConsoleOutput.innerHTML = ''; // Clear previous console errors/messages

                const fullInput = equationInput.value;

                // Basic check: Is input likely equations or standard JS?
                 const looksLikeEquations = /(\bk\b|polar:|parametric:|implicit:|=)/.test(fullInput) && !/function|var|let|const|document|window|console|alert|prompt/.test(fullInput.substring(0, 300));

                 if (!looksLikeEquations) {
                     console.log("Input doesn't look like equations. Assuming standard JS. Aborting graph plot.");
                     isGraphModeActive = false;
                     parsedEquationData = []; // Clear old data
                     animPlayPauseButton.disabled = true;
                     animResetButton.disabled = true;
                     kValueDisplayContainer.style.display = 'none';
                     // Let the standard preview logic in main.js handle this
                     // Trigger the original refresh function if possible/needed
                      if (typeof window.updatePreview === 'function') {
                         console.log("Calling standard updatePreview()...");
                         window.updatePreview(); // Assuming main.js exposes this
                      } else {
                         console.warn("Standard updatePreview function not found.");
                         graphOutputDiv.innerHTML = `<div style='padding: 20px; color: var(--text-secondary); text-align: center;'>Input doesn't seem to be graph equations. Standard preview function not found.</div>`;
                      }
                     return; // Exit graph plotting
                 }

                 // --- Proceed with Graph Plotting ---
                 console.log("Input recognized as potential equations. Proceeding with plotGraph.");
                 isGraphModeActive = true; // Set graph mode flag
                 graphOutputDiv.innerHTML = ''; // Clear previous plot or preview


                const separators = /[;&\n]+/; // Split by semicolon, ampersand, or newline
                const equationStrings = fullInput.split(separators).filter(s => s.trim() !== ''); // Filter empty strings

                parsedEquationData = []; // Reset parsed data
                const allErrors = [];
                requiresK = false; // Reset k requirement flag

                equationStrings.forEach((eqStr, index) => {
                    const result = parseSingleEquation(eqStr);
                    if (result.error) {
                        allErrors.push(`Eq #${index + 1}: ${result.error}`);
                    }
                    if (result.data) {
                        parsedEquationData.push(result.data);
                        if (result.usesK) {
                            requiresK = true; // Set flag if any equation uses 'k'
                        }
                    }
                });

                // Display parsing errors in the console
                if (allErrors.length > 0) {
                    displayGraphError("Equation Parsing Errors:\n" + allErrors.join('\n'));
                }

                // Update animation controls based on whether 'k' is used
                 animPlayPauseButton.disabled = !requiresK || parsedEquationData.length === 0;
                 animResetButton.disabled = true; // Reset is only enabled after playing
                 kValueDisplayContainer.style.display = requiresK && parsedEquationData.length > 0 ? 'inline-block' : 'none';

                // Read k range/step from inputs
                 kMin = parseFloat(kMinInput.value) || 0;
                 kMax = parseFloat(kMaxInput.value) || 10;
                 kStep = parseFloat(kStepInput.value) || 0.1;
                 // Basic validation for step direction
                 if (kMin > kMax && kStep > 0) kStep = -0.1; // Auto-reverse step if min > max
                 if (kMin < kMax && kStep < 0) kStep = 0.1;  // Auto-reverse step if max > min
                 if (kMin === kMax && kStep !==0) kStep = 0; // Step is 0 if min == max
                 if (kStep === 0 && kMin !== kMax) kStep = (kMax > kMin) ? 0.1 : -0.1; // Avoid zero step if range exists
                 // Ensure inputs reflect potentially corrected step
                 kStepInput.value = kStep;


                 kValue = kMin; // Start k at the minimum value
                 updateKDisplay();

                // Plot the initial frame (k = kMin) if we have valid data
                if (parsedEquationData.length > 0) {
                    // Get initial dimensions
                    currentPlotOptions.width = graphOutputDiv.clientWidth;
                    currentPlotOptions.height = graphOutputDiv.clientHeight;
                    // Reset domains for new plot
                    currentPlotOptions.xAxis = { domain: [-10, 10] };
                    currentPlotOptions.yAxis = { domain: [-10, 10] };
                    drawCurrentFrame(); // Draw the first frame at k = kMin
                } else {
                    plotInstance = null;
                    currentPlotOptions = {}; // Clear options
                     graphOutputDiv.innerHTML = `<div style='padding: 20px; color: var(--text-secondary); text-align: center;'>No valid equations found to plot.${allErrors.length > 0 ? ' See console for details.' : ''}</div>`;
                    if (allErrors.length === 0 && fullInput.trim() !== '') {
                         displayGraphError('No valid equations found.');
                     }
                }
            }

            // --- Event Listeners ---
            // Use the refresh button to trigger plotting
             generateButton.addEventListener('click', plotGraph);

            // Optional: Plot on Enter in JS Editor (if Shift is not pressed)
            equationInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault(); // Prevent newline
                    plotGraph(); // Trigger plot
                }
            });

            // Animation Control Listeners
            animPlayPauseButton.addEventListener('click', () => {
                if (!isGraphModeActive) return;
                if (isAnimating) {
                    pauseAnimation();
                } else {
                    startAnimation();
                }
            });

            animResetButton.addEventListener('click', () => {
                 if (!isGraphModeActive) return;
                 resetAnimation();
            });

            // Update k range/step immediately if changed - reset animation if running
             [kMinInput, kMaxInput, kStepInput].forEach(input => {
                 input.addEventListener('change', () => {
                    const wasAnimating = isAnimating;
                    stopAnimation(); // Stop if running

                    // Re-read and validate values
                    kMin = parseFloat(kMinInput.value) || 0;
                    kMax = parseFloat(kMaxInput.value) || 10;
                    kStep = parseFloat(kStepInput.value) || 0.1;
                    if (kMin > kMax && kStep > 0) kStep = -0.1;
                    if (kMin < kMax && kStep < 0) kStep = 0.1;
                    if (kMin === kMax) kStep = 0;
                    if (kStep === 0 && kMin !== kMax) kStep = (kMax > kMin) ? 0.1 : -0.1;
                    kStepInput.value = kStep; // Update input field if corrected

                    kValue = kMin; // Reset k to new minimum
                    updateKDisplay();

                    // Redraw initial frame only if graph mode is active and equations exist
                     if(isGraphModeActive && parsedEquationData.length > 0) {
                         drawCurrentFrame();
                    }
                    animResetButton.disabled = true; // Reset becomes disabled
                    // Re-enable play button if k is required
                    animPlayPauseButton.disabled = !requiresK || parsedEquationData.length === 0;
                 });
             });


            // --- Resize Handling ---
             let resizeTimeout;
            window.addEventListener('resize', () => {
                 if (!isGraphModeActive || !plotInstance) return; // Only resize if graph is active

                 clearTimeout(resizeTimeout);
                 resizeTimeout = setTimeout(() => {
                    const newWidth = graphOutputDiv.clientWidth;
                    const newHeight = graphOutputDiv.clientHeight;

                    if (!newWidth || !newHeight || newWidth <= 0 || newHeight <= 0) return; // Avoid resize if dimensions are invalid

                    console.log("Resizing graph...");

                    // Update stored dimensions
                    currentPlotOptions.width = newWidth;
                    currentPlotOptions.height = newHeight;

                    // Redraw only if we have a valid plot setup and equations
                    if (parsedEquationData.length > 0) {
                         const wasAnimating = isAnimating;
                         if (wasAnimating) pauseAnimation(); // Pause during resize redraw

                         drawCurrentFrame(); // Redraw with new size

                         if (wasAnimating && requiresK) startAnimation(); // Resume if it was animating
                    }
                }, 250); // Debounce resize events
            });

            // --- Initial Setup ---
            updateKDisplay(); // Show initial k=0.00
            // Don't store initial size until first plot
            // currentPlotOptions.width = graphOutputDiv.clientWidth;
            // currentPlotOptions.height = graphOutputDiv.clientHeight;

        }); // End DOMContentLoaded
    </script>

</body>
</html>